<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Foma Data Aligner</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { theme: { extend: { fontFamily: { sans: ["Inter","system-ui","-apple-system","Segoe UI","Roboto","Ubuntu","Cantarell","Noto Sans","Helvetica Neue","Arial","sans-serif"] }}}}
  </script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    .dropzone { border: 2px dashed rgb(203 213 225); border-radius: 1rem; }
    .dropzone.dragover { border-color: rgb(59 130 246); background: rgb(239 246 255); }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
    @media (max-width: 1024px) { .grid-2 { grid-template-columns: 1fr; } }
    .table-wrap { max-height: 60vh; overflow: auto; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .pass { color: #047857; }
    .fail { color: #b91c1c; }
    /* Styles for Tabbed UI */
    .tab-btn { transition: all 0.15s ease; border-radius: 0.5rem 0.5rem 0 0; }
    .tab-btn:not(.active) { background-color: transparent; border-color: transparent; border-bottom-color: rgb(203 213 225); }
    .tab-btn.active { background-color: white; border-color: rgb(203 213 225); border-bottom-color: white; color: rgb(15 23 42); box-shadow: 0 -2px 5px rgba(0,0,0,0.05); }
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <div class="max-w-6xl mx-auto p-6 space-y-8">
    <header class="flex items-center justify-between">
      <h1 class="text-3xl font-bold text-slate-900">Foma Data Aligner</h1>
    </header>

    <!-- INPUT & UPLOAD SECTION -->
    <section class="grid-2 bg-white p-6 rounded-2xl shadow-lg border border-slate-100">
      <!-- Left: Input data -->
      <div class="space-y-4">
        <h2 class="text-xl font-semibold border-b pb-2">1. Paste Input Data</h2>
        <p class="text-sm text-slate-600">The first identified column will be the default <span class="font-semibold">FourthID</span>.</p>
        <textarea id="inputTextarea" class="w-full h-48 rounded-xl p-3 border border-slate-200 bg-slate-50 mono focus:border-slate-400" placeholder="Paste your IDs or delimited data here..."></textarea>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
          <div>
            <label class="block text-xs font-medium text-slate-700 mb-1">Input Delimiter</label>
            <select id="inputDelimiter" class="w-full rounded-lg border border-slate-300 p-2 bg-white text-sm">
              <option value="auto" selected>Auto detect</option>
              <option value=",">Comma</option>
              <option value="\t">Tab</option>
              <option value=";">Semicolon</option>
              <option value="|">Pipe</option>
            </select>
          </div>
          <div>
            <label class="block text-xs font-medium text-slate-700 mb-1">FourthID Column</label>
            <select id="inputFourthCol" class="w-full rounded-lg border border-slate-300 p-2 bg-white text-sm">
              <option value="FourthID" selected>FourthID</option>
            </select>
          </div>
          <div class="flex gap-2">
            <button id="parseInputBtn" class="flex-1 px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition">Parse Input</button>
            <button id="clearInputBtn" class="px-4 py-2 rounded-lg bg-slate-200 hover:bg-slate-300 transition">Clear</button>
          </div>
        </div>
        <div id="inputPreview" class="text-sm text-slate-600 pt-2"></div>
      </div>

      <!-- Right: Excel file -->
      <div class="space-y-4">
        <h2 class="text-xl font-semibold border-b pb-2">2. Drop Excel File</h2>
        <p class="text-sm text-slate-600">The file will be used as the lookup source containing the matching <span class="font-semibold">FourthID</span> column.</p>
        <div id="dropzone" class="dropzone p-6 bg-slate-50 flex flex-col items-center justify-center text-slate-600 h-28 cursor-pointer rounded-xl transition">
          <div class="text-center">
            <div class="text-sm font-medium">Drop .xlsx or .xls here</div>
            <div class="text-xs">or click to select file</div>
          </div>
          <input id="fileInput" type="file" accept=".xlsx,.xls" class="hidden" />
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
          <div>
            <label class="block text-xs font-medium text-slate-700 mb-1">Worksheet</label>
            <select id="sheetSelect" class="w-full rounded-lg border border-slate-300 p-2 bg-white text-sm"></select>
          </div>
          <div>
            <label class="block text-xs font-medium text-slate-700 mb-1">Upload FourthID Column</label>
            <select id="uploadFourthCol" class="w-full rounded-lg border border-slate-300 p-2 bg-white text-sm"></select>
          </div>
          <div>
            <button id="useThisSheetBtn" class="px-4 py-2 rounded-lg bg-indigo-600 text-white w-full hover:bg-indigo-700 transition">Use Selected Sheet</button>
          </div>
        </div>
        <div id="uploadPreview" class="text-sm text-slate-600 pt-2"></div>
      </div>
    </section>

    <!-- MATCHING & RESULTS SECTION -->
    <section class="space-y-4">
      <h2 class="text-xl font-semibold">3. Match and Review Results</h2>
      
      <!-- Options and Run/Download Buttons -->
      <div class="bg-white p-4 rounded-xl shadow-md border border-slate-100">
        <h3 class="text-sm font-medium text-slate-700 mb-2">Normalisation Options:</h3>
        <div class="grid grid-cols-2 lg:grid-cols-4 gap-3">
          <label class="flex items-center gap-2 text-sm"><input id="optDedup" type="checkbox" class="rounded text-indigo-600 focus:ring-indigo-500" checked> Deduplicate input (keep first)</label>
          <label class="flex items-center gap-2 text-sm"><input id="optKeepDigits" type="checkbox" class="rounded text-indigo-600 focus:ring-indigo-500" checked> Keep digits only</label>
          <label class="flex items-center gap-2 text-sm"><input id="optStripZeros" type="checkbox" class="rounded text-indigo-600 focus:ring-indigo-500"> Strip leading zeros</label>
          <label class="flex items-center gap-2 text-sm"><input id="optTrimSpaces" type="checkbox" class="rounded text-indigo-600 focus:ring-indigo-500" checked> Trim spaces</label>
        </div>
        
        <div class="flex flex-wrap gap-3 mt-4 pt-3 border-t border-slate-100">
          <button id="matchBtn" class="px-6 py-2 rounded-lg bg-emerald-600 text-white font-medium hover:bg-emerald-700 transition">Run Match</button>
          <button id="downloadXlsxBtn" class="px-6 py-2 rounded-lg bg-slate-900 text-white hover:bg-slate-700 transition" disabled>Download XLSX</button>
          <button id="downloadCsvBtn" class="px-6 py-2 rounded-lg bg-slate-200 hover:bg-slate-300 transition" disabled>Download CSV</button>
        </div>
        <div id="resultInfo" class="text-sm text-slate-600 mt-3 font-medium"></div>
      </div>

      <!-- Tab Controls -->
      <div id="resultTabs" class="flex gap-1 border-b border-slate-200 -mb-[1px]">
          <button data-tab="matched" class="tab-btn active px-4 py-2 text-sm font-medium transition text-slate-900 border border-slate-200 border-b-white bg-white">Matched (<span id="countMatched">0</span>)</button>
          <button data-tab="input-missed" class="tab-btn px-4 py-2 text-sm font-medium text-slate-600 hover:bg-slate-100 transition">Input Missed (<span id="countInputMissed">0</span>)</button>
          <button data-tab="upload-missed" class="tab-btn px-4 py-2 text-sm font-medium text-slate-600 hover:bg-slate-100 transition">Upload Missed (<span id="countUploadMissed">0</span>)</button>
      </div>

      <!-- Tab Content (Table) -->
      <div id="resultContent" class="table-wrap bg-white rounded-xl border border-slate-200 shadow-xl">
        <table id="resultTable" class="min-w-full text-sm">
          <thead class="sticky top-0 bg-slate-100"></thead>
          <tbody>
            <tr><td colspan="100" class="text-center p-8 text-slate-500">Run the match to see the results here.</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- Footer -->
    <footer class="text-xs text-slate-500 pt-8 pb-4 border-t border-slate-200 mt-8">
        <p>Foma v0.2 • © 2025</p>
    </footer>
  </div>

  <script>
    // State containers
    let inputRows = [];          // Array of objects from pasted input
    let inputColumns = [];       // Header list for input
    let inputFourthKey = 'FourthID';

    let workbook = null;         // XLSX workbook
    let uploadSheets = [];       // Sheet names
    let uploadRows = [];         // Active sheet rows as objects
    let uploadColumns = [];      // Header list for upload
    let uploadFourthKey = 'FourthID';

    let resultRows = [];         // Matched rows (Input + Upload fields)
    let inputMissedRows = [];    // Input rows that did not find a match
    let uploadMissedRows = [];   // Upload rows that were not used in a match

    let activeResultTab = 'matched'; // Current active tab

    // Helpers
    const byId = id => document.getElementById(id);

    function normaliseId(val) {
      const keepDigits = byId('optKeepDigits') ? byId('optKeepDigits').checked : true;
      const stripZeros = byId('optStripZeros') ? byId('optStripZeros').checked : false;
      const trimSpaces = byId('optTrimSpaces') ? byId('optTrimSpaces').checked : true;
      let s = val == null ? '' : String(val);
      if (trimSpaces) s = s.trim();
      if (keepDigits) {
        let out = '';
        for (let i = 0; i < s.length; i++) {
          const code = s.charCodeAt(i);
          if (code >= 48 && code <= 57) out += s[i];
        }
        s = out;
      }
      if (stripZeros) {
        let j = 0; while (j < s.length && s[j] === '0') j++;
        s = s.slice(j);
      }
      return s;
    }

    function detectDelimiter(text) {
      if (byId('inputDelimiter').value !== 'auto') return byId('inputDelimiter').value;
      const line = (text.split(/\r?\n/).find(l => l.trim().length) || '').trim();
      const counts = { ',': (line.match(/,/g)||[]).length, '\t': (line.match(/\t/g)||[]).length, ';': (line.match(/;/g)||[]).length, '|': (line.match(/\|/g)||[]).length };
      const best = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0];
      return best && best[1] > 0 ? best[0] : null;
    }

    function parseDelimited(text, delim) {
      const rows = [];
      const lines = text.split(/\r?\n/).filter(l => l.length);
      for (const ln of lines) {
        // Use a regex to split only for tabs, otherwise a simple string split
        const parts = delim === '\t' ? ln.split(/\t/) : (delim ? ln.split(delim) : [ln]);
        rows.push(parts.map(s => s.replace(/^\s+|\s+$/g, '')));
      }
      return rows;
    }

    function toObjects(rows) {
      if (!rows.length) return { columns: [], objects: [] };
      const hasHeader = rows[0].length > 1 || /[A-Za-z]/.test(rows[0][0]);
      let columns, startIdx;
      if (hasHeader && rows.length > 1) { columns = rows[0]; startIdx = 1; }
      else { columns = ['FourthID']; startIdx = 0; }
      // Clean up column names and ensure uniqueness if possible (essential for object keys)
      columns = columns.map(c => c || 'FourthID').map((c, i, arr) => {
        let count = arr.slice(0, i).filter(v => v === c).length;
        return count > 0 ? `${c}_${count}` : c;
      });

      const objects = [];
      for (let i = startIdx; i < rows.length; i++) {
        const row = rows[i];
        const obj = {};
        for (let c = 0; c < columns.length; c++) {
          obj[columns[c]] = row[c] ?? '';
        }
        // If it was a simple list, ensure it's not a completely empty row
        if (columns.length === 1 && !obj[columns[0]].trim() && rows.length > 1) continue;
        objects.push(obj);
      }
      return { columns, objects };
    }

    function renderPreview(el, rows, columns, label) {
      const count = rows.length;
      const cols = columns.length;
      if (!count) { el.innerHTML = ''; return; }
      const fourthKey = el.id === 'inputPreview' ? inputFourthKey : uploadFourthKey;
      const sampleKeys = rows.slice(0, 3).map(r => normaliseId(r[fourthKey] ?? '')).join(', ');
      el.innerHTML = `<span class="font-medium">${label}:</span> ${count} rows, ${cols} columns. FourthID sample → [${sampleKeys}${count > 3 ? '...':''}]`;
    }

    function setSelectOptions(selectEl, options, selected) {
      selectEl.innerHTML = options.map(o => `<option value="${o}">${o}</option>`).join('');
      const choice = options.includes(selected) ? selected : options[0] || '';
      selectEl.value = choice;
    }

    function renderTable(rows) {
      const thead = byId('resultTable').querySelector('thead');
      const tbody = byId('resultTable').querySelector('tbody');
      
      if (!rows || !rows.length) {
        thead.innerHTML = '';
        tbody.innerHTML = `<tr><td colspan="100" class="text-center p-8 text-slate-500">No data to display in this view.</td></tr>`;
        return;
      }

      const columns = Object.keys(rows[0]);
      thead.innerHTML = `<tr>${columns.map(c=>`<th class="text-left p-3 border-b border-slate-200 bg-slate-100 sticky top-0 font-semibold">${c}</th>`).join('')}</tr>`;
      tbody.innerHTML = rows.map(r => `<tr>${columns.map(c=>`<td class="p-3 border-b border-slate-100">${escapeHtml(String(r[c] ?? ''))}</td>`).join('')}</tr>`).join('');
    }

    function renderResultUI(tabName) {
      activeResultTab = tabName;
      const allTabs = document.querySelectorAll('#resultTabs .tab-btn');
      allTabs.forEach(btn => {
          btn.classList.remove('active', 'bg-white', 'text-slate-900', 'border-b-white', 'border', 'border-slate-200', '-mb-[1px]');
          btn.classList.add('text-slate-600', 'hover:bg-slate-100');
      });

      const activeBtn = document.querySelector(`#resultTabs button[data-tab="${tabName}"]`);
      if (activeBtn) {
          activeBtn.classList.add('active', 'bg-white', 'text-slate-900', 'border-b-white', 'border', 'border-slate-200', '-mb-[1px]');
          activeBtn.classList.remove('text-slate-600', 'hover:bg-slate-100');
      }

      let rowsToRender = [];

      if (tabName === 'matched') {
          rowsToRender = resultRows;
      } else if (tabName === 'input-missed') {
          // Transform inputMissedRows to only show input columns
          rowsToRender = inputMissedRows.map(r => {
              const out = {};
              for (const c of inputColumns) out[c] = r[c] ?? '';
              return out;
          });
      } else if (tabName === 'upload-missed') {
          // Transform uploadMissedRows to only show upload columns
          rowsToRender = uploadMissedRows.map(r => {
              const out = {};
              for (const c of uploadColumns) out[c] = r[c] ?? '';
              return out;
          });
      }

      renderTable(rowsToRender);
    }

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
    }

    // --- Download Functions ---

    function downloadCSV(filename, rows) {
      if (!rows.length) return;
      const cols = Object.keys(rows[0]);
      const csv = [cols.map(c => csvCell(c)).join(',')].concat(rows.map(r => cols.map(c => csvCell(r[c])).join(','))).join("\r\n");
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();
    }

    function csvCell(v) {
      if (v == null) return '';
      const s = String(v);
      if (/[",\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
      return s;
    }

    function downloadXLSX(filename) {
      const wb = XLSX.utils.book_new();

      // Sheet 1: Matched
      if (resultRows.length) {
        const wsMatched = XLSX.utils.json_to_sheet(resultRows);
        XLSX.utils.book_append_sheet(wb, wsMatched, 'Matched');
      }

      // Sheet 2: Input Missed
      if (inputMissedRows.length) {
        // Only include columns that were in the original input
        const inputMissedClean = inputMissedRows.map(r => {
            const out = {};
            for (const c of inputColumns) out[c] = r[c] ?? '';
            return out;
        });
        const wsInputMissed = XLSX.utils.json_to_sheet(inputMissedClean);
        XLSX.utils.book_append_sheet(wb, wsInputMissed, 'Input Missed');
      }

      // Sheet 3: Upload Missed
      if (uploadMissedRows.length) {
        // Only include columns that were in the original upload
        const uploadMissedClean = uploadMissedRows.map(r => {
            const out = {};
            for (const c of uploadColumns) out[c] = r[c] ?? '';
            return out;
        });
        const wsUploadMissed = XLSX.utils.json_to_sheet(uploadMissedClean);
        XLSX.utils.book_append_sheet(wb, wsUploadMissed, 'Upload Missed');
      }

      if (wb.SheetNames.length === 0) {
        alert('No data generated to download.');
        return;
      }
      XLSX.writeFile(wb, filename);
    }

    // --- Input Handlers ---

    byId('parseInputBtn').addEventListener('click', () => {
      const text = byId('inputTextarea').value.trim();
      if (!text) { inputRows = []; inputColumns = []; renderPreview(byId('inputPreview'), inputRows, inputColumns, ''); setSelectOptions(byId('inputFourthCol'), ['FourthID'], 'FourthID'); return; }
      const delim = detectDelimiter(text);
      const rows = parseDelimited(text, delim);
      const { columns, objects } = toObjects(rows);
      inputRows = objects;
      inputColumns = columns.filter(Boolean); // Ensure no null/empty strings in headers
      
      const guess = columns.find(c => /^fourth\s*id$/i.test(c)) || columns[0] || 'FourthID';
      setSelectOptions(byId('inputFourthCol'), inputColumns.length ? inputColumns : ['FourthID'], guess);
      inputFourthKey = byId('inputFourthCol').value;
      renderPreview(byId('inputPreview'), inputRows, inputColumns, 'Input parsed');
    });

    byId('inputFourthCol').addEventListener('change', e => { inputFourthKey = e.target.value; });

    byId('clearInputBtn').addEventListener('click', () => {
      byId('inputTextarea').value = '';
      inputRows = []; inputColumns = []; inputFourthKey = 'FourthID';
      setSelectOptions(byId('inputFourthCol'), ['FourthID'], 'FourthID');
      renderPreview(byId('inputPreview'), [], [], '');
    });

    // --- Dropzone Handlers ---
    const dz = byId('dropzone');
    dz.addEventListener('click', () => byId('fileInput').click());
    dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('dragover'); });
    dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
    dz.addEventListener('drop', e => {
      e.preventDefault(); dz.classList.remove('dragover');
      if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
    });
    byId('fileInput').addEventListener('change', e => {
      if (e.target.files && e.target.files[0]) handleFile(e.target.files[0]);
    });

    function handleFile(file) {
      const reader = new FileReader();
      reader.onload = e => {
        const data = new Uint8Array(e.target.result);
        workbook = XLSX.read(data, { type: 'array' });
        uploadSheets = workbook.SheetNames || [];
        setSelectOptions(byId('sheetSelect'), uploadSheets, uploadSheets[0] || '');
        byId('uploadPreview').textContent = uploadSheets.length ? `Workbook loaded: ${file.name}. ${uploadSheets.length} sheet(s).` : 'No sheets found.';
        loadActiveSheet();
      };
      reader.readAsArrayBuffer(file);
      byId('fileInput').value = ''; // Reset file input
    }

    function loadActiveSheet() {
      const sheetName = byId('sheetSelect').value;
      if (!workbook || !sheetName) return;
      const ws = workbook.Sheets[sheetName];
      const json = XLSX.utils.sheet_to_json(ws, { defval: '' });
      uploadRows = json;

      // Infer columns from sheet headers
      const range = ws['!ref'] ? XLSX.utils.decode_range(ws['!ref']) : null;
      const headerRow = range ? range.s.r : 0;
      let headers = [];
      if (range) {
        for (let C = range.s.c; C <= range.e.c; ++C) {
          const cell = ws[XLSX.utils.encode_cell({ r: headerRow, c: C })];
          const v = cell && cell.v != null ? String(cell.v) : '';
          headers.push(v || `Col${C+1}`);
        }
      }
      
      // Fallback to keys of first object
      if (!headers.some(h => h) && json.length) {
        headers = Object.keys(json[0]);
      }
      
      uploadColumns = headers.filter(Boolean);

      const guess = uploadColumns.find(c => /^fourth\s*id$/i.test(c)) || uploadColumns[0] || 'FourthID';
      setSelectOptions(byId('uploadFourthCol'), uploadColumns.length ? uploadColumns : ['FourthID'], guess);
      uploadFourthKey = byId('uploadFourthCol').value;
      renderPreview(byId('uploadPreview'), uploadRows, uploadColumns, 'Sheet parsed');
    }

    byId('sheetSelect').addEventListener('change', loadActiveSheet);
    byId('uploadFourthCol').addEventListener('change', e => { uploadFourthKey = e.target.value; });
    byId('useThisSheetBtn').addEventListener('click', loadActiveSheet);

    // --- Match Logic ---
    byId('matchBtn').addEventListener('click', () => {
      if (!inputRows.length) { alert('Please parse your input data first.'); return; }
      if (!uploadRows.length) { alert('Please load your Excel sheet first.'); return; }

      // 1. Prepare Input Rows (Deduplicate if selected)
      let inRows = inputRows;
      const dedup = byId('optDedup') ? byId('optDedup').checked : true;
      if (dedup) {
        const seen = new Set();
        inRows = inputRows.filter(r => {
          const k = normaliseId(r[inputFourthKey] ?? '');
          if (!k) return true; // keep blanks to preserve alignment
          if (seen.has(k)) return false;
          seen.add(k);
          return true;
        });
      }

      // 2. Prepare Upload Map (Unique by Normalised ID)
      const uploadMap = new Map();
      for (const r of uploadRows) {
        const raw = r[uploadFourthKey];
        const k = normaliseId(raw);
        // Only map the FIRST occurrence of a normalised ID from the upload sheet
        if (k && !uploadMap.has(k)) {
          uploadMap.set(k, r);
        }
      }

      // 3. Perform Matching and Identify Missed
      const inputMapCols = new Set(inputColumns);
      const inputPref = inputColumns.filter(c => inputMapCols.has(c));
      const matchedUploadRecords = new Set();
      
      inputMissedRows = [];
      resultRows = [];
      let found = 0;

      resultRows = inRows.map(r => {
        const keyRaw = r[inputFourthKey] ?? '';
        const keyN = normaliseId(keyRaw);
        const match = uploadMap.get(keyN);
        
        const out = {};
        for (const c of inputPref) out[`Input.${c}`] = r[c] ?? '';

        if (keyN && match) {
          found++;
          matchedUploadRecords.add(match);
          for (const c of uploadColumns) out[`Upload.${c}`] = match[c] ?? '';
        } else {
          // Input record missed a match
          inputMissedRows.push(r);
          for (const c of uploadColumns) out[`Upload.${c}`] = '';
        }
        return out;
      });
      
      // 4. Identify Upload Missed (Upload records never used in a match)
      uploadMissedRows = uploadRows.filter(r => {
        // Only consider rows that had a valid FourthID to begin with
        const k = normaliseId(r[uploadFourthKey] ?? '');
        return k && !matchedUploadRecords.has(r);
      });

      const totalInput = inRows.length;
      const missing = inputMissedRows.length;

      // 5. Update UI Counts and Display
      byId('countMatched').textContent = found;
      byId('countInputMissed').textContent = missing;
      byId('countUploadMissed').textContent = uploadMissedRows.length;

      byId('resultInfo').textContent = `${totalInput} input rows processed. Matches: ${found}. Input Missed: ${missing}. Upload Missed: ${uploadMissedRows.length}.`;
      
      // Switch to the view that has content, prioritizing Matched > Input Missed > Upload Missed
      let defaultTab = 'matched';
      if (found === 0) {
        defaultTab = inputMissedRows.length > 0 ? 'input-missed' : 'upload-missed';
      }
      renderResultUI(defaultTab);
      
      byId('downloadXlsxBtn').disabled = !(resultRows.length || inputMissedRows.length || uploadMissedRows.length);
      byId('downloadCsvBtn').disabled = !resultRows.length; // CSV only for Matched output
    });

    byId('downloadCsvBtn').addEventListener('click', () => downloadCSV('fourthid_matched.csv', resultRows));
    byId('downloadXlsxBtn').addEventListener('click', () => downloadXLSX('fourthid_full_report.xlsx'));

    // --- Tab Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('#resultTabs .tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                renderResultUI(e.currentTarget.dataset.tab);
            });
        });
        renderResultUI('matched'); // Initialize table placeholder
    });
  </script>
</body>
</html>
